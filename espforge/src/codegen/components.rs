use anyhow::{Result, anyhow};
use crate::parse::model::{ProjectModel, Component, ResourceResolver};

pub fn generate_components_source(model: &ProjectModel) -> Result<String> {
    let mut struct_fields = Vec::new();
    let mut init_lines = Vec::new();
    let mut imports = Vec::new();

    // Default imports
    imports.push("use crate::platform::components::led::LED;");
    // Add other component imports here as they are added to the platform

    for (name, component) in &model.components {
        match component {
            Component::LED { gpio } => {
                // 1. Resolve the GPIO Reference (e.g., "$gpio2" -> 18)
                let pin_num = resolve_pin_number(model, gpio)?;

                // 2. Add field to struct
                struct_fields.push(format!("    pub {}: LED,", name));

                // 3. Add initialization logic
                init_lines.push(format!("        let {} = LED::new({});", name, pin_num));
            }
            // Handle other components (Button, etc.) here
            _ => log::warn!("Skipping unimplemented component type for {}", name),
        }
    }

    // Sort fields for deterministic output
    struct_fields.sort();
    init_lines.sort();

    let imports_code = imports.join("\n");
    let fields_code = struct_fields.join("\n");
    
    // Construct the initialization return struct (e.g., "red_led,")
    let return_struct_fields: Vec<String> = model.components.keys()
        .map(|k| format!("            {},", k))
        .collect();
    let return_code = return_struct_fields.join("\n");

    Ok(format!(
r#"// Generated by espforge
#![allow(dead_code)]
{imports_code}

pub struct Components {{
{fields_code}
}}

impl Components {{
    pub fn new() -> Self {{
{init_lines} // e.g. let red_led = LED::new(18);

        Self {{
{return_code}
        }}
    }}
}}
"#
    , init_lines = init_lines.join("\n")))
}

fn resolve_pin_number(model: &ProjectModel, reference: &str) -> Result<u8> {
    if let Some(esp32) = &model.esp32 {
        // Try resolving as GPIO config first
        if let Some(gpio_config) = esp32.resolve::<crate::parse::model::GpioPinConfig>(reference) {
            return Ok(gpio_config.pin);
        }
    }
    
    // If we supported raw integers (e.g. "18"), we would parse it here.
    // For now, fail if not a reference.
    Err(anyhow!("Could not resolve pin reference: {}", reference))
}

