use crate::parse::model::{Component, ProjectModel, ResourceResolver};
use anyhow::{Context, Result, anyhow};
use proc_macro2::{Literal, TokenStream};
use quote::{format_ident, quote};

pub fn generate_components_source(model: &ProjectModel) -> Result<String> {
    let mut struct_fields = Vec::new();
    let mut init_lines = Vec::new();
    let mut sorted_components: Vec<_> = model.components.iter().collect();
    sorted_components.sort_by_key(|(name, _)| *name);

    for (name, component) in sorted_components {
        let field_name = format_ident!("{}", name);

        match component {
            Component::LED { gpio } => {
                // 1. Resolve the GPIO Reference (e.g., "$gpio2" -> 18)
                let pin_num = resolve_pin_number(model, gpio)?;
                let pin_lit = Literal::u8_unsuffixed(pin_num);

                // 2. Add field to struct
                struct_fields.push(quote! {
                    pub #field_name: crate::platform::components::led::LED
                });

                // 3. Add initialization logic
                init_lines.push(quote! {
                    let #field_name = crate::platform::components::led::LED::new(#pin_lit);
                });
            }
            // Handle other components (Button, etc.) here
            _ => log::warn!("Skipping unimplemented component type for {}", name),
        }
    }

    let mut sorted_keys: Vec<_> = model.components.keys().collect();
    sorted_keys.sort();

    let return_fields: Vec<TokenStream> = sorted_keys
        .iter()
        .map(|k| {
            let ident = format_ident!("{}", k);
            quote! { #ident }
        })
        .collect();

    let output = quote! {
        // Generated by espforge

        pub struct Components {
            #(#struct_fields),*
        }

        impl Components {
            pub fn new() -> Self {
                #(#init_lines)*

                Self {
                    #(#return_fields),*
                }
            }
        }
    };

    let syntax_tree =
        syn::parse2(output).context("Failed to parse generated tokens into valid Rust syntax")?;
    let formatted_source = prettyplease::unparse(&syntax_tree);
    Ok(formatted_source.to_string())
}

fn resolve_pin_number(model: &ProjectModel, reference: &str) -> Result<u8> {
    if let Some(esp32) = &model.esp32
        && let Some(gpio_config) = esp32.resolve::<crate::parse::model::GpioPinConfig>(reference) {
            return Ok(gpio_config.pin);
        }
    Err(anyhow!("Could not resolve pin reference: {}", reference))
}
