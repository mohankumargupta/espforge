use anyhow::{Result, anyhow};
use crate::parse::model::{ProjectModel, Component, ResourceResolver};
use quote::{quote, format_ident};
use proc_macro2::{Literal, TokenStream};

pub fn generate_components_source(model: &ProjectModel) -> Result<String> {
    let mut struct_fields = Vec::new();
    let mut init_lines = Vec::new();
    
    // Default imports are implicitly handled by fully qualified paths in quote!,
    // or we can add them to the top.
    
    // Sort components for deterministic output
    let mut sorted_components: Vec<_> = model.components.iter().collect();
    sorted_components.sort_by_key(|(name, _)| *name);

    for (name, component) in sorted_components {
        let field_name = format_ident!("{}", name);
        
        match component {
            Component::LED { gpio } => {
                // 1. Resolve the GPIO Reference (e.g., "$gpio2" -> 18)
                let pin_num = resolve_pin_number(model, gpio)?;
                let pin_lit = Literal::u8_unsuffixed(pin_num);

                // 2. Add field to struct
                struct_fields.push(quote! {
                    pub #field_name: crate::platform::components::led::LED
                });

                // 3. Add initialization logic
                init_lines.push(quote! {
                    let #field_name = crate::platform::components::led::LED::new(#pin_lit);
                });
            }
            // Handle other components (Button, etc.) here
            _ => log::warn!("Skipping unimplemented component type for {}", name),
        }
    }

    let field_names: Vec<TokenStream> = model.components.keys()
        .map(|k| {
            let ident = format_ident!("{}", k);
            quote! { #ident }
        })
        .collect();
    
    // Ensure field names in return struct are also sorted or match init vars
    // The previous loop created `let name = ...`, so we just need to return `name,`
    // However, the hashmap iteration order for `field_names` might differ from `sorted_components`.
    // Let's rebuild field_names from the sorted list to be safe.
    let mut sorted_keys: Vec<_> = model.components.keys().collect();
    sorted_keys.sort();
    
    let return_fields: Vec<TokenStream> = sorted_keys.iter().map(|k| {
        let ident = format_ident!("{}", k);
        quote! { #ident }
    }).collect();

    let output = quote! {
        // Generated by espforge
        #![allow(dead_code)]
        use crate::platform::components::led::LED;

        pub struct Components {
            #(#struct_fields),*
        }

        impl Components {
            pub fn new() -> Self {
                #(#init_lines)*

                Self {
                    #(#return_fields),*
                }
            }
        }
    };

    Ok(output.to_string())
}

fn resolve_pin_number(model: &ProjectModel, reference: &str) -> Result<u8> {
    if let Some(esp32) = &model.esp32 {
        // Try resolving as GPIO config first
        if let Some(gpio_config) = esp32.resolve::<crate::parse::model::GpioPinConfig>(reference) {
            return Ok(gpio_config.pin);
        }
    }
    
    // If we supported raw integers (e.g. "18"), we would parse it here.
    // For now, fail if not a reference.
    Err(anyhow!("Could not resolve pin reference: {}", reference))
}

