use crate::parse::model::{Component, ProjectModel};
use anyhow::{Context, Result, anyhow};
use proc_macro2::{Ident, TokenStream};
use quote::{format_ident, quote};

pub fn generate_components_source(model: &ProjectModel) -> Result<String> {
    // Stage 1: Generate the struct that owns the raw silicon
    // This creates 'PeripheralRegistry'
    let hardware_struct = generate_peripheral_registry(model)?;

    // Stage 2: Generate the struct that owns the platform components
    // This creates 'ComponentRegistry' and injects resources from PeripheralRegistry
    let components_struct = generate_component_registry(model)?;

    let output = quote! {
        // Generated by espforge
        // Low-level dependencies for the Hardware Registry
        use esp_hal::{
            gpio::{AnyPin, Io},
            spi::{master::Spi, SpiMode},
            i2c::master::I2c,
            peripherals::Peripherals,
            Blocking,
        };
        use core::cell::RefCell;

        // Platform dependencies for the Component Registry
        // This ensures the generated Components struct only sees 'platform' types
        use crate::platform;

        #hardware_struct

        #components_struct
    };

    let syntax_tree = syn::parse2(output).context("Failed to parse generated tokens")?;
    Ok(prettyplease::unparse(&syntax_tree))
}

fn generate_peripheral_registry(model: &ProjectModel) -> Result<TokenStream> {
    let mut fields = Vec::new();
    let mut init_logic = Vec::new();
    let mut struct_init = Vec::new();

    // 1. Initialize IO System
    init_logic.push(quote! {
        let io = Io::new(p.GPIO, p.IO_MUX);
    });

    if let Some(esp32) = &model.esp32 {
        // 2. Generate SPI Buses
        for (name, cfg) in &esp32.spi {
            let field = format_ident!("{}", name);
            let spi_peri = format_ident!("SPI{}", cfg.spi);
            let sck = format_ident!("gpio{}", cfg.sck);
            let mosi = format_ident!("gpio{}", cfg.mosi);
            let freq = cfg.frequency;

            // Generate RefCell<Spi> field
            fields.push(quote! { pub #field: RefCell<Spi<'static, Blocking>> });

            // Generate Spi::new() init code
            let miso_cfg = if let Some(m) = cfg.miso {
                let m_pin = format_ident!("gpio{}", m);
                quote! { .with_miso(io.pins.#m_pin) }
            } else {
                quote! {}
            };

            init_logic.push(quote! {
                let #field = Spi::new(p.#spi_peri, #freq.kHz(), SpiMode::Mode0, clocks)
                    .with_sck(io.pins.#sck)
                    .with_mosi(io.pins.#mosi)
                    #miso_cfg;
            });

            struct_init.push(quote! { #field: RefCell::new(#field) });
        }

        // 3. Generate I2C Buses
        for (name, cfg) in &esp32.i2c {
            let field = format_ident!("{}", name);
            let i2c_peri = format_ident!("I2C{}", cfg.i2c);
            let sda = format_ident!("gpio{}", cfg.sda);
            let scl = format_ident!("gpio{}", cfg.scl);
            let freq = cfg.frequency;

            fields.push(quote! { pub #field: RefCell<I2c<'static, Blocking>> });

            init_logic.push(quote! {
                let #field = I2c::new(p.#i2c_peri, esp_hal::i2c::master::Config::default().with_frequency(#freq.kHz()))
                    .unwrap()
                    .with_sda(io.pins.#sda)
                    .with_scl(io.pins.#scl);
            });

            struct_init.push(quote! { #field: RefCell::new(#field) });
        }

        // 4. Generate GPIO Pins
        // Note: We only expose pins defined in the YAML gpio section to avoid clutter
        // We wrap them in RefCell<Option<AnyPin>> to allow ComponentRegistry to "take" ownership of them
        for (name, cfg) in &esp32.gpio {
            let field = format_ident!("{}", name);
            let pin_num = format_ident!("gpio{}", cfg.pin);

            fields.push(quote! { pub #field: RefCell<Option<AnyPin<'static>>> });
            struct_init.push(quote! { #field: RefCell::new(Some(io.pins.#pin_num.into())) });
        }
    }

    Ok(quote! {
        /// Owns the raw hardware peripherals and buses
        pub struct PeripheralRegistry {
            #(#fields),*
        }

        impl PeripheralRegistry {
            pub fn new(p: Peripherals, clocks: &esp_hal::clock::Clocks) -> Self {
                #(#init_logic)*
                Self { #(#struct_init),* }
            }
        }
    })
}

fn generate_component_registry(model: &ProjectModel) -> Result<TokenStream> {
    let mut fields = Vec::new();
    let mut init_logic = Vec::new();
    let mut struct_init = Vec::new();

    let mut sorted_components: Vec<_> = model.components.iter().collect();
    sorted_components.sort_by_key(|(name, _)| *name);

    for (name, component) in sorted_components {
        let field = format_ident!("{}", name);

        match component {
            Component::LED { gpio } => {
                let pin_ref = resolve_resource_ident(gpio)?;

                // Field Type: Platform Component
                fields.push(quote! { pub #field: platform::components::led::LED });

                // Init: Take the pin from registry -> Wrap in Platform GPIO -> Create Component
                init_logic.push(quote! {
                    let #field = platform::components::led::LED::new(
                        platform::gpio::GPIOOutput::from_pin(
                            registry.#pin_ref.borrow_mut().take().expect("Pin already claimed")
                        )
                    );
                });
            }
            Component::Button { gpio, pull_up } => {
                let pin_ref = resolve_resource_ident(gpio)?;
                let pull_up_val = *pull_up;

                fields.push(quote! { pub #field: platform::gpio::GPIOInput });
                init_logic.push(quote! {
                    let #field = platform::gpio::GPIOInput::from_pin(
                        registry.#pin_ref.borrow_mut().take().expect("Pin already claimed"),
                        #pull_up_val,
                        false
                    );
                });
            }
            Component::SpiDevice { spi, cs } => {
                let spi_ref = resolve_resource_ident(spi)?;

                if let Some(cs_ref_str) = cs {
                    let cs_ref = resolve_resource_ident(cs_ref_str)?;

                    fields.push(quote! { pub #field: platform::bus::SpiDevice<'a> });

                    init_logic.push(quote! {
                        let #field = platform::bus::SpiDevice::new(
                            &registry.#spi_ref,
                            registry.#cs_ref.borrow_mut().take().expect("CS Pin already claimed")
                        );
                    });
                }
            }
            Component::I2cDevice { i2c, address: _ } => {
                let i2c_ref = resolve_resource_ident(i2c)?;
                fields.push(quote! { pub #field: platform::bus::I2cDevice<'a> });
                init_logic.push(quote! {
                   let #field = platform::bus::I2cDevice::new(&registry.#i2c_ref);
                });
            }
            _ => {}
        }
        struct_init.push(quote! { #field });
    }

    Ok(quote! {
        /// Owns high-level components constructed from platform wrappers
        pub struct ComponentRegistry<'a> {
            #(#fields),*
        }

        impl<'a> ComponentRegistry<'a> {
            pub fn new(registry: &'a PeripheralRegistry) -> Self {
                #(#init_logic)*
                Self { #(#struct_init),* }
            }
        }
    })
}

fn resolve_resource_ident(reference: &str) -> Result<Ident> {
    let name = reference
        .strip_prefix('$')
        .ok_or_else(|| anyhow!("Invalid resource reference {}", reference))?;
    Ok(format_ident!("{}", name))
}
