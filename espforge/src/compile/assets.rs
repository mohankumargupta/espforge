use anyhow::{Context, Result};
use std::fs;
use std::path::Path;

/// Copies the Wokwi configuration files from the source to the project directory.
pub fn copy_wokwi_files(base_dir: &Path, project_dir: &Path) -> Result<()> {
    // diagram.json and wokwi.toml are generated by esp-generate, so we override them if present.
    // chip.json and chip.wasm are custom parts for Wokwi, we include them if present.
    let files_to_check = ["diagram.json", "wokwi.toml", "chip.json", "chip.wasm"];
    for filename in files_to_check {
        let source_path = base_dir.join(filename);
        if source_path.exists() {
            let dest_path = project_dir.join(filename);
            fs::copy(&source_path, &dest_path)
                .with_context(|| format!("Failed to copy {} to project", filename))?;
            println!("   Included custom file: {}", filename);
        }
    }

    // If we have a custom chip binary and definition, ensure wokwi.toml knows about it
    let chip_wasm = project_dir.join("chip.wasm");
    let chip_json = project_dir.join("chip.json");

    if chip_wasm.exists() && chip_json.exists() {
        update_wokwi_config_for_chip(project_dir)?;
    }

    Ok(())
}

fn update_wokwi_config_for_chip(project_dir: &Path) -> Result<()> {
    let wokwi_path = project_dir.join("wokwi.toml");
    if !wokwi_path.exists() {
        return Ok(());
    }

    let content = fs::read_to_string(&wokwi_path).context("Failed to read wokwi.toml")?;
    let mut doc = content.parse::<toml_edit::DocumentMut>().context("Failed to parse wokwi.toml")?;

    let chips = doc.entry("chip").or_insert(toml_edit::Item::ArrayOfTables(toml_edit::ArrayOfTables::new()));
    
    if let Some(arr) = chips.as_array_of_tables_mut() {
        // Check if a chip with name "chip" already exists to avoid duplication
        let exists = arr.iter().any(|t| t.get("name").and_then(|s| s.as_str()) == Some("chip"));
        
        if !exists {
            let mut table = toml_edit::Table::new();
            table.insert("name", toml_edit::value("chip"));
            table.insert("binary", toml_edit::value("chip.wasm"));
            arr.push(table);
            
            fs::write(wokwi_path, doc.to_string())?;
            println!("   Updated wokwi.toml to include chip.wasm");
        }
    }
    Ok(())
}

/// Extracts the platform abstraction layer (espforge_platform) into the generated project.
pub fn provision_platform_assets(project_dir: &Path, src_dir: &Path) -> Result<()> {
    let platform_temp = project_dir.join(".espforge_temp");

    if platform_temp.exists() {
        fs::remove_dir_all(&platform_temp)?;
    }
    fs::create_dir_all(&platform_temp)?;

    // Access the embedded directory defined in lib.rs
    crate::PLATFORM_SRC
        .extract(&platform_temp)
        .context("Failed to extract platform assets")?;

    let assets_dir = platform_temp.join("assets");
    let platform_dest = src_dir.join("platform");

    if assets_dir.exists() {
        copy_recursive(&assets_dir, &platform_dest)?;
    }

    let _ = fs::remove_dir_all(platform_temp);
    Ok(())
}

pub fn provision_device_assets(project_dir: &Path, src_dir: &Path, devices: &[String]) -> Result<()> {
    if devices.is_empty() { return Ok(()); }

    let temp_dir = project_dir.join(".espforge_devices_temp");
    if temp_dir.exists() { fs::remove_dir_all(&temp_dir)?; }
    fs::create_dir_all(&temp_dir)?;

    crate::DEVICES_SRC.extract(&temp_dir).context("Failed to extract device assets")?;

    // The structure of espforge_devices is src/devices/<device_name>
    let source_devices_root = temp_dir.join("src/devices");
    let target_devices_root = src_dir.join("devices");
    
    fs::create_dir_all(&target_devices_root)?;

    // Create a mod.rs for the devices module
    let mut mod_rs_content = String::new();

    for device in devices {
        let src = source_devices_root.join(device);
        if !src.exists() {
            println!("⚠️  Warning: Device driver '{}' not found in espforge_devices", device);
            continue;
        }

        let dst = target_devices_root.join(device);
        copy_recursive(&src, &dst)?;
        
        mod_rs_content.push_str(&format!("pub mod {};\n", device));
        println!("   Included device driver: {}", device);
    }

    fs::write(target_devices_root.join("mod.rs"), mod_rs_content)?;

    let _ = fs::remove_dir_all(temp_dir);
    Ok(())
}


/// Copies the user's application logic into the generated project.
pub fn inject_app_code(base_dir: &Path, src_dir: &Path) -> Result<()> {
    let rust_source = base_dir.join("app/rust/app.rs");
    let target = src_dir.join("app.rs");

    if rust_source.exists() {
        fs::copy(&rust_source, &target)?;
        println!("   Included app logic from app/rust/app.rs");
    } else {
        println!("⚠️  Warning: No app code found. Generating stub.");
        fs::write(
            &target,
            r#"
            // Stub generated by espforge
            pub fn setup(_: &mut crate::Context) {}
            pub fn forever(_: &mut crate::Context) {}
        "#,
        )?;
    }
    Ok(())
}

/// Helper to copy directories recursively
fn copy_recursive(src: &Path, dst: &Path) -> Result<()> {
    if !dst.exists() {
        fs::create_dir_all(dst)?;
    }
    for entry in fs::read_dir(src)? {
        let entry = entry?;
        let file_type = entry.file_type()?;
        let target_path = dst.join(entry.file_name());

        if file_type.is_dir() {
            copy_recursive(&entry.path(), &target_path)?;
        } else if entry.file_name() == "lib.rs" {
            // Rename internal lib.rs to mod.rs when moving to submodules
            fs::copy(entry.path(), dst.join("mod.rs"))?;
        } else {
            fs::copy(entry.path(), target_path)?;
        }
    }
    Ok(())
}
