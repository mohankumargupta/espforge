use anyhow::{Context, Result};
use std::fs;
use std::path::Path;

/// Copies the Wokwi configuration files from the source to the project directory.
pub fn copy_wokwi_files(base_dir: &Path, project_dir: &Path) -> Result<()> {
    let files_to_check = ["diagram.json", "wokwi.toml", "chip.json", "chip.wasm"];
    for filename in files_to_check {
        let source_path = base_dir.join(filename);
        if source_path.exists() {
            let dest_path = project_dir.join(filename);
            fs::copy(&source_path, &dest_path)
                .with_context(|| format!("Failed to copy {} to project", filename))?;
            println!("   Overriding generated {} with custom file", filename);
        }
    }
    Ok(())
}

/// Extracts the platform abstraction layer (espforge_platform) into the generated project.
pub fn provision_platform_assets(project_dir: &Path, src_dir: &Path) -> Result<()> {
    let platform_temp = project_dir.join(".espforge_temp");

    if platform_temp.exists() {
        fs::remove_dir_all(&platform_temp)?;
    }
    fs::create_dir_all(&platform_temp)?;

    // Access the embedded directory defined in lib.rs
    crate::PLATFORM_SRC
        .extract(&platform_temp)
        .context("Failed to extract platform assets")?;

    let assets_dir = platform_temp.join("assets");
    let platform_dest = src_dir.join("platform");

    if assets_dir.exists() {
        copy_recursive(&assets_dir, &platform_dest)?;
    }

    let _ = fs::remove_dir_all(platform_temp);
    Ok(())
}

/// Copies the user's application logic into the generated project.
pub fn inject_app_code(base_dir: &Path, src_dir: &Path) -> Result<()> {
    let rust_source = base_dir.join("app/rust/app.rs");
    let target = src_dir.join("app.rs");

    if rust_source.exists() {
        fs::copy(&rust_source, &target)?;
        println!("   Included app logic from app/rust/app.rs");
    } else {
        println!("⚠️  Warning: No app code found. Generating stub.");
        fs::write(
            &target,
            r#"
            // Stub generated by espforge
            pub fn setup(_: &mut crate::Context) {}
            pub fn forever(_: &mut crate::Context) {}
        "#,
        )?;
    }
    Ok(())
}

/// Helper to copy directories recursively
fn copy_recursive(src: &Path, dst: &Path) -> Result<()> {
    if !dst.exists() {
        fs::create_dir_all(dst)?;
    }
    for entry in fs::read_dir(src)? {
        let entry = entry?;
        let file_type = entry.file_type()?;
        let target_path = dst.join(entry.file_name());

        if file_type.is_dir() {
            copy_recursive(&entry.path(), &target_path)?;
        } else if entry.file_name() == "lib.rs" {
            // Rename internal lib.rs to mod.rs when moving to submodules
            fs::copy(entry.path(), dst.join("mod.rs"))?;
        } else {
            fs::copy(entry.path(), target_path)?;
        }
    }
    Ok(())
}
