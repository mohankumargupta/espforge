use std::fs;
use std::path::Path;
use anyhow::{Context, Result};
use toml_edit::DocumentMut;

use crate::codegen::espgenerate::esp_generate;
use crate::parse::ConfigurationOrchestrator;

pub fn compile_project(config_path: &Path) -> Result<()> {
    //
    println!("ðŸ” Parsing configuration...");
    let content = fs::read_to_string(config_path).context(format!(
        "Failed to read configuration file: {}",
        config_path.display()
    ))?;

    let orchestrator = ConfigurationOrchestrator::new();
    let model = orchestrator.compile(&content)?;

    println!("   Project: {}", model.get_name());
    println!("   Chip:    {}", model.get_chip());

    //
    println!("ðŸ”— Resolving configuration...");
    //resolve::resolve_project(&mut model)?;

    //
    println!("ðŸ”¨ Generating artifacts...");    
    esp_generate(model.get_name(), model.get_chip(), false)?;

    let base_dir = config_path.parent().unwrap_or_else(|| Path::new("."));
    let current_dir = std::env::current_dir().context("Failed to get current directory")?;
    let project_dir = current_dir.join(model.get_name());
    let src_dir = project_dir.join("src");

    provision_platform_assets(&project_dir, &src_dir)?;

    setup_library_structure(&src_dir)?;
    inject_app_code(base_dir, &src_dir)?;

    update_cargo_manifest(&project_dir)?;
    generate_entry_point(model.get_name(), &src_dir)?;

    println!("âœ¨ Project compiled successfully!");
    Ok(())
}

fn provision_platform_assets(project_dir: &Path, src_dir: &Path) -> Result<()> {
    let platform_temp = project_dir.join(".espforge_temp");
    fs::create_dir_all(&platform_temp)?;
    
    crate::PLATFORM_SRC.extract(&platform_temp).context("Failed to extract platform assets")?;

    let assets_dir = platform_temp.join("assets");
    let platform_dest = src_dir.join("platform");
    
    if assets_dir.exists() {
        copy_recursive(&assets_dir, &platform_dest)?;
    }
    
    let _ = fs::remove_dir_all(platform_temp);
    Ok(())
}

fn copy_recursive(src: &Path, dst: &Path) -> Result<()> {
    if !dst.exists() {
        fs::create_dir_all(dst)?;
    }
    for entry in fs::read_dir(src)? {
        let entry = entry?;
        let file_type = entry.file_type()?;
        let target_path = dst.join(entry.file_name());
        
        if file_type.is_dir() {
            copy_recursive(&entry.path(), &target_path)?;
        } else {
            if entry.file_name() == "lib.rs" {
                fs::copy(entry.path(), dst.join("mod.rs"))?;
            } else {
                fs::copy(entry.path(), target_path)?;
            }
        }
    }
    Ok(())
}

fn setup_library_structure(src_dir: &Path) -> Result<()> {
    let lib_rs_content = r#"#![no_std]
pub mod app;
pub mod platform;
// Wildcard export platform items so they are easily accessible in app code
pub use platform::*;
"#;
    fs::write(src_dir.join("lib.rs"), lib_rs_content)
        .context("Failed to write src/lib.rs")?;
    Ok(())
}

fn inject_app_code(base_dir: &Path, src_dir: &Path) -> Result<()> {
    // Support two folder structures:
    // 1. Nested: app/rust/app.rs (Classic/Complex)
    // 2. Flat:   app/app.rs      (Simple/Blink)
    let app_rust_src_nested = base_dir.join("app/rust/app.rs");
    let app_rust_src_flat = base_dir.join("app/app.rs");
    let target_app_rs = src_dir.join("app.rs");
    
    if app_rust_src_nested.exists() {
        fs::copy(&app_rust_src_nested, &target_app_rs)
            .context("Failed to copy app.rs to src/app.rs")?;
        println!("   Included app logic from app/rust/app.rs");
    } else if app_rust_src_flat.exists() {
        fs::copy(&app_rust_src_flat, &target_app_rs)
            .context("Failed to copy app.rs to src/app.rs")?;
        println!("   Included app logic from app/app.rs");
    } else {
        println!("âš ï¸  Warning: No app code found at app/rust/app.rs or app/app.rs. Generating stub.");
        fs::write(&target_app_rs, r#"
            // Stub generated by espforge
            pub fn setup(_: &mut crate::Context) {}
            pub fn forever(_: &mut crate::Context) {}
        "#)?;
    }
    Ok(())
}

/// Updates Cargo.toml. (Place to add dependencies derived from components in the future).
fn update_cargo_manifest(project_dir: &Path) -> Result<()> {
    let cargo_toml_path = project_dir.join("Cargo.toml");
    if cargo_toml_path.exists() {
        // Just validation for now
        let cargo_toml_content = fs::read_to_string(&cargo_toml_path)?;
        let _manifest = cargo_toml_content.parse::<DocumentMut>()?;
    }
    Ok(())
}

/// Generates the `main.rs` entry point using templates.
fn generate_entry_point(project_name: &str, src_dir: &Path) -> Result<()> {
    // Rust crates use underscores, project folders often use hyphens
    let crate_name = project_name.replace('-', "_");
    
    let main_rs_content = espforge_templates::render_main(None, &crate_name, "", "")
        .map_err(|e| anyhow::anyhow!("Failed to render template: {}", e))?;

    let main_rs_path = src_dir.join("bin/main.rs");
    if let Some(parent) = main_rs_path.parent() {
        fs::create_dir_all(parent)?;
    }
    
    fs::write(&main_rs_path, main_rs_content)
        .context("Failed to write generated main.rs")?;
        
    Ok(())
}

